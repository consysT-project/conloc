(declare-datatype ClassB ( (ClassB (value Int)) ) )
(declare-datatype ClassC ( (ClassC (value Int)) ) )
(declare-datatype ClassA ( (ClassA (getB ClassB) (getC ClassC)) ) )


(declare-fun ClassB.inc_state (ClassB) ClassB)
(declare-fun ClassC.inc_state (ClassC) ClassC)

(declare-fun ClassA.merge_state (ClassA ClassA) ClassA)

(declare-fun InvA (ClassA) Bool)


; Definitions of operations

; Definition of ClassB.inc
(assert
	(forall ((b ClassB))
		(= (ClassB.inc_state b) (ClassB (+ (value b) 1)) )
	)
)


; Definition of ClassC.inc
(assert
	(forall ((c ClassC))
		(= (ClassC.inc_state c) (ClassC (+ (value c) 1)) )
	)
)


; Defintion of merge

; Definition of ClassA.merge
(assert
	(forall ((a1 ClassA) (a2 ClassA))
		(let (
				(b1 (value (getB a1)))
				(b2 (value (getB a2)))
				(c1 (value (getC a1)))
				(c2 (value (getC a2)))
			)
			(= (ClassA.merge_state a1 a2)
				(ClassA
					(ClassB (ite (> b1 b2) b1 (ite (> b2 b1) b2 b1)))
					(ClassC (ite (> c1 c2) c1 (ite (> c2 c1) c2 c1)))
				)
			)
		)
	)
)


; Definition of invariant

; Definition of Invariant_A
(assert
	(forall ((a ClassA))
		(=
			(InvA a)
			(>= (- (value (getB a)) (value (getC a))) 0)
		)
	)
)


; Properties


; merge is commutative
(assert
	(forall ((a1 ClassA) (a2 ClassA))
		(= (ClassA.merge_state a1 a2)	(ClassA.merge_state a2 a1))
	)
)

; merge is idempotent
(assert
	(forall ((a1 ClassA))
		(= (ClassA.merge_state a1 a1)	a1)
	)
)


(check-sat)


; B.inc satisfies the invariant = TRUE
(assert
	(forall ((a1 ClassA) (a2 ClassA))
		(=>
			(and
				(InvA a1)
				(= (getB a2) (ClassB.inc_state (getB a1)))
				(= (getC a2) (getC a1))
			)
			(InvA a2)
		)
	)
)

(check-sat)

; C.inc satisfies the invariant = FALSE
(assert
	(forall ((a1 ClassA) (a2 ClassA))
		(=>
			(and
				(InvA a1)
				(= (getB a2) (getB a1))
				(= (getC a2) (ClassC.inc_state (getC a1)))
			)
			(InvA a2)
		)
	)
)



(check-sat)


(exit)
